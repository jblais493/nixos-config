#+title: Joshua Blais' Nix Configuration

[[https://nixos.org][https://img.shields.io/badge/NixOS-unstable-blue.svg?style=flat-square&logo=NixOS&logoColor=white]]

#+BEGIN_QUOTE
*Disclaimer:* I have no idea what I am doing, so take all of this with a grain (massive boulder) of salt.
#+END_QUOTE


* Introduction
This is a literate file using [[https://orgmode.org/][org-mode]] to [[https://orgmode.org/manual/Extracting-Source-Code.html][tangle]] all code blocks to various *.nix files across the configuration. I am used to one, massive (partially) organized file (see my [[https://github.com/jblais493/nixos-config/blob/master/dotfiles/doom/config.org][Emacs Configuration]]), so this seemed natural: Documentation and configuration all in one file? How nice.

What this ends up being is, quite literally, the *One File to Rule Them All*: My *entire computing landscape is declared* right where you are looking. This is the power of Nix.

[[https://nixos.org/][NixOS]] is what I would refer to as "the endgame of systems management". I have used various distributions of Linux in the past, and while I have no gripes with the likes of Debian, Fedora, or Arch, I have always forgotten configuration settings in the past, struggled to maintain multiple machines without drift, or had breaking changes on each and every distro.

NixOS offers the bleeding edge with the stable, allowing easy rollbacks of any issues, allowing me to  continue on with work and then fix things at a later date if I have a breaking change. This is increasingly important as I host various projects and services for a broader audience and cannot deal with any downtime.

What makes this possible is:
- [[https://nixos.org/][NixOS]]
- [[https://github.com/nix-community/home-manager][home-manager]]
- [[https://github.com/serokell/deploy-rs][deploy-rs]]
- [[https://github.com/nix-community/nixos-anywhere][nixos-anywhere]]
- [[https://orgmode.org/][org-mode]] (this document)

Excited yet? Let us begin...
** Setting this all up
*** Local Installation (Laptops/Desktops)
1. Obtain [[https://nixos.org/download/][installation media for nixOS]].
2. Flash .iso to flash drive using ~dd~ or similar tool:
   #+begin_src bash
   dd if=nixos-minimal-xx.xx.iso of=/dev/sdX bs=4M status=progress
   #+end_src
3. Boot up installer and connect to internet
4. Partition your drives (example for UEFI systems):
   #+begin_src bash
   # Create partitions
   parted /dev/nvme0n1 -- mklabel gpt
   parted /dev/nvme0n1 -- mkpart primary 512MiB -8GiB
   parted /dev/nvme0n1 -- mkpart primary linux-swap -8GiB 100%
   parted /dev/nvme0n1 -- mkpart ESP fat32 1MiB 512MiB
   parted /dev/nvme0n1 -- set 3 esp on

   # Format partitions
   mkfs.ext4 -L nixos /dev/nvme0n1p1
   mkswap -L swap /dev/nvme0n1p2
   mkfs.fat -F 32 -n boot /dev/nvme0n1p3

   # Mount filesystems
   mount /dev/disk/by-label/nixos /mnt
   mkdir -p /mnt/boot
   mount /dev/disk/by-label/boot /mnt/boot
   swapon /dev/nvme0n1p2
   #+end_src
5. Generate hardware configuration:
   #+begin_src bash
   nixos-generate-config --root /mnt
   #+end_src
6. Clone this repository:
   #+begin_src bash
   cd /mnt/home
   git clone https://github.com/jblais493/nixos-config.git
   #+end_src
7. Copy the generated hardware configuration:
   #+begin_src bash
   cp /mnt/etc/nixos/hardware-configuration.nix /mnt/home/nixos-config/hosts/YOUR_HOST/
   #+end_src
8. Edit the host configuration to match your setup:
   #+begin_src bash
   # Edit hostname and any host-specific settings
   nano /mnt/home/nixos-config/hosts/YOUR_HOST/configuration.nix
   #+end_src
9. Test the configuration:
   #+begin_src bash
   cd /mnt/home/nixos-config
   nix flake check
   #+end_src
10. Install NixOS:
    #+begin_src bash
    nixos-install --flake .#YOUR_HOST
    #+end_src
11. Reboot and enjoy your declarative system!

*** Installation on VPS/headless servers
For automated server deployments, use [[https://nix-community.github.io/nixos-anywhere/quickstart.html][nixos-anywhere]].

Quick server setup:
#+begin_src bash
# Install nixos-anywhere
nix run github:nix-community/nixos-anywhere -- \
  --flake .#YOUR_SERVER_HOST \
  root@your-server-ip
#+end_src

* Dotfiles
This directory contains all dotfiles for the programs and tooling I use. I previously used [[https://www.gnu.org/software/stow/][Stow]] to organize all these config files, but now use home-manager's ~mkOutOfStoreSymlink~ to sym link and keep these files organized within this one config - simplification is beautiful. See the section on the home-manager module below.

#+begin_src bash
❯ tree -d -L 2
├── doom
│   ├── lisp
│   ├── private
│   ├── snippets
│   ├── templates
│   └── themes
├── hypr
├── kitty
├── mpd
│   └── playlists
├── nvim
│   ├── lua
│   ├── scripts
│   └── snippets
├── +STORE
│   └── dictionary
├── swaync
│   └── styles
├── tmux
│   └── tmux
├── waybar
│   ├── modules
│   └── scripts
├── wofi
├── zathura
└── zsh
#+end_src

* Hosts
** Theologica
*** README.md
#+begin_src markdown :tangle hosts/theologica/README.md
# Theologica
My daily driver machine, a Lenovo T14s gen 3 laptop.

## Specifications
- Model: Lenovo T14s Gen 3
- Purpose: Daily development and writing work
- Desktop: Hyprland

### Hardware override
Adding
#+end_src
*** configuration.nix
This declares all imported modules and specific tweaks to the Theologica host:
*** hardware-configuration.nix
#+begin_src nix :tangle hosts/theologica/hardware-configuration.nix
# This is a placeholder hardware configuration
# You'll need to generate the real one when you install NixOS
# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot.initrd.availableKernelModules = [ "nvme" "xhci_pci" "thunderbolt" "usb_storage" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-amd" ];
  boot.extraModulePackages = [ ];

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/14d03f28-59d0-4e29-8ea0-fec882ed5eac";
      fsType = "ext4";
    };

  boot.initrd.luks.devices."luks-08dfaa11-224c-4623-a507-656a67258b8c".device = "/dev/disk/by-uuid/08dfaa11-224c-4623-a507-656a67258b8c";

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/23D9-F036";
      fsType = "vfat";
      options = [ "fmask=0077" "dmask=0077" ];
    };

  swapDevices = [ ];

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.enp53s0f4u1u4u3.useDHCP = lib.mkDefault true;
  # networking.interfaces.wlp1s0.useDHCP = lib.mkDefault true;
  # networking.interfaces.wwan0.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.amd.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
#+end_src
*** Hardware Overrides
Adds in vulcan support for builtin AMD GPU
#+begin_src nix :tangle hosts/theologica/hardware-overrides.nix
# Hardware-specific overrides that don't belong in auto-generated hardware-configuration.nix
{ config, pkgs, lib, ... }:
{
  # AMD Radeon 680M (Rembrandt) Graphics Configuration
  hardware.graphics = {
    enable = true;
    enable32Bit = true;

    extraPackages = with pkgs; [
      amdvlk              # AMD Vulkan driver
      libva               # Video acceleration API
      vaapiVdpau          # VDPAU backend for VAAPI
      libvdpau-va-gl      # VDPAU driver
    ];

    extraPackages32 = with pkgs.pkgsi686Linux; [
      amdvlk              # 32-bit Vulkan for compatibility
    ];
  };

  # AMD-specific environment variables
  environment.variables = {
    AMD_VULKAN_ICD = "RADV";           # Use open-source RADV driver
    LIBVA_DRIVER_NAME = "radeonsi";    # Video acceleration driver
  };
}
#+end_src

** King
*** README.md
#+begin_src markdown :tangle hosts/king/README.md
# King

My testing machine, a Lenovo T430 laptop.

## Specifications
- Model: Lenovo T430
- Purpose: Testing configurations before deploying to main machine
- Desktop: Hyprland (testing)
#+end_src

*** configuration.nix
This declares all imported modules and specific tweaks to the King host:
#+begin_src nix hosts/king/configuration.nix
{ config, pkgs, inputs, ... }:
{
  imports = [
    # ./hardware-configuration.nix
    inputs.disko.nixosModules.disko
    ./disko.nix
    ../../modules/desktop
    ../../modules/shared
    ../../modules/cli-tui
    ../../modules/development
    ../../modules/media
  ];

  nix.settings.experimental-features = [ "nix-command" "flakes" ];

  services.openssh = {
    enable = true;
    settings = {
      PermitRootLogin = "prohibit-password";
      PasswordAuthentication = false;
    };
  };

  boot.loader.grub = {
    enable = true;
    useOSProber = true;
    enableCryptodisk = true;  # Moved this up for clarity
  };

  networking.hostName = "king"; # Define your hostname.

  users.users.joshua = {
    isNormalUser = true;
    description = "Joshua Blais";
    group = "joshua";
    initialPassword = "changeme";
    extraGroups = [ "networkmanager" "wheel" ];
  };

  users.groups.joshua = {};

  time.timeZone = "America/Edmonton";
  i18n.defaultLocale = "en_CA.UTF-8";

  environment.systemPackages = with pkgs; [
    vim
    git
  ];

  system.stateVersion = "25.05";
}
#+end_src
*** hardware-configuration.nix
#+begin_src nix :tangle hosts/king/hardware-configuration.nix
# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:
{
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];
  boot.initrd.availableKernelModules = [ "xhci_pci" "ehci_pci" "ahci" "usb_storage" "sd_mod" "sdhci_pci" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ ];
  boot.extraModulePackages = [ ];

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/2185ae84-0778-4bd1-bb8d-bfbe57103c9c";
      fsType = "ext4";
    };

  boot.initrd.luks.devices."cryptroot".device = "/dev/disk/by-uuid/69de1763-3bf7-48c9-b9e1-d68d544bd978";

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/a47882fb-56ce-4740-a56b-7d020fa6b6db";
      fsType = "ext4";
    };

  swapDevices = [ ];

  networking.useDHCP = lib.mkDefault true;
  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
#+end_src
*** Disks Configuration
#+begin_src nix :tangle hosts/king/disko.nix
{ ... }:
{
  disko.devices = {
    disk = {
      main = {
        type = "disk";
        device = "/dev/sda";
        content = {
          type = "gpt";
          partitions = {
            # BIOS boot partition - critical for GPT + legacy GRUB
            bios = {
              size = "1M";
              type = "EF02";  # BIOS boot partition type
              priority = 1;   # Make it first
            };
            boot = {
              size = "512M";
              priority = 2;
              content = {
                type = "filesystem";
                format = "ext4";
                mountpoint = "/boot";
              };
            };
            luks = {
              size = "100%";
              priority = 3;
              content = {
                type = "luks";
                name = "cryptroot";
                settings = {
                  allowDiscards = true;
                  bypassWorkqueues = true;
                };
                # Password will be prompted during disko format
                content = {
                  type = "btrfs";
                  extraArgs = [ "-f" ];
                  subvolumes = {
                    # Root - ephemeral, wiped on boot
                    "@root" = {
                      mountpoint = "/";
                      mountOptions = [ "compress=zstd" "noatime" ];
                    };
                    # Nix store - persistent
                    "@nix" = {
                      mountpoint = "/nix";
                      mountOptions = [ "compress=zstd" "noatime" ];
                    };
                    # Persistent data - explicitly opted-in state
                    "@persist" = {
                      mountpoint = "/persist";
                      mountOptions = [ "compress=zstd" "noatime" ];
                    };
                    # Snapshots for time machine
                    "@snapshots" = {
                      mountpoint = "/snapshots";
                      mountOptions = [ "compress=zstd" "noatime" ];
                    };
                  };
                };
              };
            };
          };
        };
      };
    };
    # Tmpfs for /tmp
    nodev = {
      "/tmp" = {
        fsType = "tmpfs";
        mountOptions = [ "size=4G" "mode=1777" ];
      };
    };
  };
}
#+end_src
** Axios
*** README.md
#+begin_src markdown :tangle hosts/axios/README.md
# Axios

Aurelia's machine, a Lenovo X230 laptop.

## Specifications
- Model: Lenovo X230
- Purpose: Aurelia's daily driver
- Desktop: Hyprland
#+end_src

*** configuration.nix
This declares all imported modules and specific tweaks to the King host:
#+begin_src nix :tangle hosts/axios/configuration.nix
{ config, pkgs, lib, inputs, ... }:
{
  imports = [
    ./hardware-configuration.nix
    ../../modules/desktop
    ../../modules/shared
    ../../modules/cli-tui
    ../../modules/development
    ../../modules/media
    ../../modules/security
  ];

  # Bootloader.
  boot.loader.grub.enable = true;
  boot.loader.grub.device = "/dev/sda";
  boot.loader.grub.useOSProber = true;

  # Setup keyfile
  boot.initrd.secrets = {
    "/boot/crypto_keyfile.bin" = null;
  };

  boot.loader.grub.enableCryptodisk = true;

  boot.initrd.luks.devices."luks-68e37805-7090-4a03-a958-7c3271384a93".keyFile = "/boot/crypto_keyfile.bin";
  networking.hostName = "axios";
  nix.settings.experimental-features = [ "nix-command" "flakes" ];
  # networking.wireless.enable = true;  # Enables wireless support via wpa_supplicant.

  # Enable networking
  networking.networkmanager.enable = true;

  # Enable the X11 windowing system.
  services.xserver.enable = true;

  # Enable the GNOME Desktop Environment.
  # services.displayManager.gdm.enable = true;
  services.desktopManager.gnome.enable = true;

  # Configure keymap in X11
  services.xserver.xkb = {
    layout = "us";
    variant = "";
  };

# SSH configuration
services.openssh = {
  enable = true;
  settings = {
    PermitRootLogin = "no";  # Change this to "no" for security
    PasswordAuthentication = false;  # Enable password auth temporarily
  };
};

  networking.firewall.allowedTCPPorts = [ 22 ];

users.users.joshua = {
  isNormalUser = true;
  description = "joshua";
  extraGroups = [ "networkmanager" "wheel" "uinput" "input" ];
  openssh.authorizedKeys.keys = [
    "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICCWNto66rFbOvb1VDEDuZYdwHQPfKM7+EjpnHvs3eRr joshua@joshuablais.com"
  ];
};

  environment.systemPackages = with pkgs; [
    btrfs-progs
    btrbk
    compsize
  ];

  time.timeZone = "America/Edmonton";
  i18n.defaultLocale = "en_CA.UTF-8";

  system.stateVersion = "25.05";
}
#+end_src

*** hardware-configuration.nix
#+begin_src nix :tangle hosts/axios/hardware-configuration.nix
# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot.initrd.availableKernelModules = [ "xhci_pci" "ehci_pci" "ahci" "usb_storage" "sd_mod" "sdhci_pci" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" ];
  boot.extraModulePackages = [ ];

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/b2896044-4591-45ec-a462-eff16f2fbf5b";
      fsType = "ext4";
    };

  boot.initrd.luks.devices."luks-68e37805-7090-4a03-a958-7c3271384a93".device = "/dev/disk/by-uuid/68e37805-7090-4a03-a958-7c3271384a93";

  swapDevices = [ ];

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.eno0.useDHCP = lib.mkDefault true;
  # networking.interfaces.wlp2s0.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
#+end_src
** Empirica
*** README.md
#+begin_src markdown :tangle hosts/empirica/README.md
# Empirica

Mini PC running all self-hosted services

## Specifications
- Model: Lenovo M910Q
- Purpose: Hosting all my home server stack
- Headless NixOS Server
#+end_src
*** configuration.nix
Empirica runs all my [[https://joshblais.com/posts/selfhosting/][selfhosted services to get me free from subscriptions]]

*** hardware-configuration.nix

** Alexandria
*** README.md
#+begin_src markdown :tangle hosts/alexandria/README.md
# Alexandria
Hetzner minimal server

## Specifications
#+end_src
*** configuration.nix
#+begin_src nix :tangle hosts/alexandria/configuration.nix
{ config, pkgs, inputs, ... }:
{
  imports = [
    ./hardware-configuration.nix
    ../../modules/security
  ];

  networking.hostName = "alexandria";

  nix.settings.experimental-features = [ "nix-command" "flakes" ];

  boot.loader.grub = {
    enable = true;
    devices = [ "/dev/sda" ];
  };

  users.users.joshua = {
    isNormalUser = true;
    description = "Joshua Blais";
    group = "joshua";
    extraGroups = [ "networkmanager" "wheel" ];
  };

  users.groups.joshua = {};

  time.timeZone = "America/Edmonton";
  i18n.defaultLocale = "en_CA.UTF-8";

  environment.systemPackages = with pkgs; [
    vim
    git
  ];

  system.stateVersion = "24.11";
}
#+end_src

*** hardware-configuration.nix
#+begin_src nix :tangle hosts/alexandria/hardware-configuration.nix
# This is a placeholder hardware configuration
# You'll need to generate the real one when you install NixOS
{ config, lib, pkgs, modulesPath, ... }:
{
  imports = [ ];

  # Placeholder hardware config
  boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "nvme" "usb_storage" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" ];
  boot.extraModulePackages = [ ];

  # Placeholder filesystem config
  fileSystems."/" = {
    device = "/dev/disk/by-uuid/placeholder";
    fsType = "ext4";
  };

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
#+end_src
** Empire
*** README.md
#+begin_src markdown :tangle hosts/empire/README.md
# Empire

Hetzner server running all containers currently -

TODO: migrate all services to nixOS.
## Specifications
#+end_src
*** configuration.nix
*** hardware-configuration.nix

** Citadel
** Phone
*** Nix-on-droid
#+begin_src nix
{ config, lib, pkgs, ... }:
{
  # Terminal appearance - Nord theme
  terminal.colors = {
    background = "#2e3440";
    foreground = "#d8dee9";
    cursor = "#d8dee9";

    # Normal colors
    color0 = "#3b4252";  # black
    color1 = "#bf616a";  # red
    color2 = "#a3be8c";  # green
    color3 = "#ebcb8b";  # yellow
    color4 = "#81a1c1";  # blue
    color5 = "#b48ead";  # magenta
    color6 = "#88c0d0";  # cyan
    color7 = "#e5e9f0";  # white

    # Bright colors
    color8 = "#4c566a";   # bright black
    color9 = "#bf616a";   # bright red
    color10 = "#a3be8c";  # bright green
    color11 = "#ebcb8b";  # bright yellow
    color12 = "#81a1c1";  # bright blue
    color13 = "#b48ead";  # bright magenta
    color14 = "#8fbcbb";  # bright cyan
    color15 = "#eceff4";  # bright white
  };

  # Font configuration
  terminal.font = "${pkgs.nerdfonts.override { fonts = [ "GeistMono" ]; }}/share/fonts/truetype/NerdFonts/GeistMonoNerdFont-Regular.ttf";

  environment.packages = with pkgs; [
    # Editors
    vim
    neovim
    git

    # SSH
    openssh
    shadow
    gnupg

    # Core utilities
    coreutils
    procps
    iproute2
    nettools
    gnugrep
    which
    killall
    hostname
    man
    gzip

    # Power user tools
    tmux        # Terminal multiplexer - essential
    htop        # Better top
    fd          # Better find
    ripgrep     # Better grep
    fzf         # Fuzzy finder
    bat         # Better cat with syntax highlighting
    eza         # Better ls
    zoxide      # Smarter cd
    delta       # Better git diff

    # Fonts
    (nerdfonts.override { fonts = [ "GeistMono" ]; })
  ];

  # SSH daemon configuration
  build.activation.sshd-setup = ''
    mkdir -p $HOME/.ssh
    chmod 700 $HOME/.ssh

    if [ ! -f $HOME/.ssh/ssh_host_ed25519_key ]; then
      ${pkgs.openssh}/bin/ssh-keygen -t ed25519 -f $HOME/.ssh/ssh_host_ed25519_key -N ""
    fi
    if [ ! -f $HOME/.ssh/ssh_host_rsa_key ]; then
      ${pkgs.openssh}/bin/ssh-keygen -t rsa -f $HOME/.ssh/ssh_host_rsa_key -N ""
    fi
    chmod 600 $HOME/.ssh/ssh_host_*

    cat > $HOME/.ssh/sshd_config << 'EOF'
Port 8022
HostKey /data/data/com.termux.nix/files/home/.ssh/ssh_host_rsa_key
HostKey /data/data/com.termux.nix/files/home/.ssh/ssh_host_ed25519_key
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
PasswordAuthentication no
PermitRootLogin no
PidFile /data/data/com.termux.nix/files/home/.ssh/sshd.pid
EOF

    touch $HOME/.ssh/authorized_keys
    chmod 600 $HOME/.ssh/authorized_keys

    mkdir -p $HOME/.local/bin
    cat > $HOME/.local/bin/start-ssh << 'SCRIPT'
#!/usr/bin/env bash
${pkgs.openssh}/bin/sshd -f $HOME/.ssh/sshd_config
SCRIPT
    chmod +x $HOME/.local/bin/start-ssh
  '';

  environment.sessionVariables = {
    PATH = "$HOME/.local/bin:$PATH";
    EDITOR = "nvim";
    PAGER = "less";

    # Better defaults
    LESS = "-R";  # Allow colors in less
    BAT_THEME = "Nord";
  };

  environment.etcBackupExtension = ".bak";

  system.stateVersion = "24.05";

  nix.extraOptions = ''
    experimental-features = nix-command flakes
  '';
#+end_src
* Modules
** Home-manager
I use [[https://github.com/nix-community/home-manager][home-manager]] to manage all dotfiles that require customization. I don't agree with rewriting my configs when you can just symlink them using ~mkOutOfStoreSymlink~
*** default.nix
Pulls in all modules for home-manager systems (desktops/workstations/laptops)
*** dotfiles.nix
Adds in MkOutOfStore for immediate update when dotfiles are edited
*** activation.nix
Scripts to setup a new machine with directories in their correct locations.
*** theming.nix
Defines system theming for all applications
*** firefox.nix
This configures extensions and settings in firefox

** Development
*** default.nix
Basic development packages for ease of development and deployment.

*** base.nix
*** go.nix
*** rust.nix
*** python.nix
*** doom.nix
Emacs configuration using DOOM emacs.

To setup:
#+begin_src bash
git clone --depth 1 https://github.com/doomemacs/doomemacs ~/.emacs.d
~/.emacs.d/bin/doom install

# Get dotfiles into correct location
nixos-rebuild switch 

# run initial doom sync
doomsync
#+end_src

** CLI/TUI
*** default.nix
Imports all cli-tui utilities for daily drivers.
*** shell
**** tmux.nix
Tmux setup for servers/desktops
***** Packages
- tmux
- tmuxifier
**** zsh.nix
ZSH setup. Used across all machines
***** packages
- starship
- fzf
- fd
- ripgrep
***** notes
I will keep the aliases in my .zshrc as it is portable across systems rather than nixifying the aliases etc.
*** core-utils.nix
**** packages
- eza
- bat
- fd
- ripgrep-all
- zoxide
- fzf
- yazi
- tree
- zip
- unzip
- jq
- rsync
- coreutils
**** notes

*** git.nix
All git related configuration
**** packages
- git
- tea
- lazygit
**** notes
All git configuration is done here. No longer using .gitconfig

*** neovim.nix
Neovim installed
**** packages
- neovim

*** network.nix
Networking related CLI/TUIs
*** nix.nix
Nix packages for quality of life and enhancing nixOS
*** podman.nix
Podman service - **not needed on most machines
*** security.nix
GPG/age and password-store
*** system-tools.nix
system tooling

** Desktop
*** default.nix
This declares all desktop modules for importing to desktop/laptops.
*** hyprland.nix (system module)
Hyprland setup
*** kmonad.nix
Kmonad setup for keyboard layout using Colemak DH and various enhancements.
*** fonts.nix
Font setup, Alegreya for reading, Geist for monospace, montserrat for professional.
*** audio.nix
Piplewire, alsa, other minor audio tweaks
*** bluetooth.nix
Bluetooth services for desktops
*** printing.nix
Setup printing availability for desktop machines.
*** browsers.nix
Brave and Tor browsers.
*** applications.nix
Various desktop applications for comms, files, etc.
*** display-manager.nix
Login screen.
*** storage.nix
Dealing with automatic mounting of drives, creating new ISOs etc.
*** theming.nix
Setting nord theming and styles. Replace packages here for setting your own custom theme.
*** boot.nix
This sets up boot screens and adds logos with plymouth
*** power.nix
Enables power settings and modules for laptops (we can pull this out in the future for a laptop profile)
*** email.nix
Setting up email in mu4e in emacs, packages necessary:
*** gaming.nix
Add OSRS Runelite 

** Shared
*** default.nix
*** networking.nix
** Server
*** Empirica
**** default.nix
Defines all services running on our homelab
** Security
*** default.nix
*** fail2ban.nix
*** keychain.nix
** Media
*** default.nix
*** music.nix
** Secrets
This will define secrets decryption for desktops
*** secrets-joshua
Secrets for user joshua
*** secrets-empirica
Secrets for homelab machine
* Overlays
* Secrets
We manage secrets with [[https://github.com/ryantm/agenix][agenix]].

The workflow for adding a secret is as follows:
1. Add secret to secrets.nix - specify which keys can decrypt it
2. Create the secret: agenix -e new-secret.age
3. Rekey existing secrets if you added new machines: agenix -r
4. Deploy: Your NixOS systems will automatically decrypt the secrets they have keys for

You can retrieve Machine SSH keys by running ~cat /etc/ssh/ssh_host_ed25519_key.pub~ in any Linux machine with ssh enabled.
** secrets.nix
Create an age key for each of your machines using:
#+begin_src bash
age-keygen -o key.txt
#+end_src

and include the public key with the machine:
#+begin_src bash
age-keygen -y key.txt
#+end_src
and add that machine to the group.

Also, add the public key to the .age-recipients file in the root directory.

I generally keep secrets at the machine level, the user "joshua" is my main user and thus has access to all keys.

* flake.nix
Defines all machines as a flake, inputs etc. and where we deploy.

