#+title: Joshua Blais' Nix Configuration

[[https://nixos.org][https://img.shields.io/badge/NixOS-unstable-blue.svg?style=flat-square&logo=NixOS&logoColor=white]]

#+BEGIN_QUOTE
*Disclaimer:* I have no idea what I am doing, so take all of this with a grain (massive boulder) of salt.
#+END_QUOTE

This is a literate file using [[https://orgmode.org/][org-mode]] to [[https://orgmode.org/manual/Extracting-Source-Code.html][tangle]] all code blocks to various Nix files across the configuration. I am used to one, massive, partially organized file (see my Emacs Configuration), so this seemed natural: Documentation and configuration all in one file? How nice.


* Introduction
NixOS is what I would refer to as "the endgame of system management". I have used various distributions of Linux in the past, and while I have no gripes with the likes of Debian, Fedora, or Arch, I have always forgotten configuration settings in the past, or had breaking changes on each and every distro. NixOS offers the bleeding edge with the stable, allowing easy rollbacks of any issues, allowing me to  continue on with work and then fix things at a later date. This is increasingly important as I host various projects and services for a broader audience and cannot deal with any downtime.

What makes this possible is:
- NixOS
- Home-manager
- deploy-rs
- nixos-anywhere
- org-mode (this document)

With this one document, my *entire computing landscape is declared*. This is the power of Nix.
* Dotfiles
This directory contains all dotfiles for the programs and tooling I use. I use home-manager just to symlink these configurations to the correct locations, but not to manage the files.
#+begin_src bash
❯ tree -d -L 2
├── doom
│   ├── lisp
│   ├── private
│   ├── snippets
│   ├── templates
│   └── themes
├── hypr
├── kitty
├── mpd
│   └── playlists
├── nvim
│   ├── lua
│   ├── scripts
│   └── snippets
├── +STORE
│   └── dictionary
├── swaync
│   └── styles
├── tmux
│   └── tmux
├── waybar
│   ├── modules
│   └── scripts
├── wofi
├── zathura
└── zsh
#+end_src

* Hosts
** Theologica
*** README.md
#+begin_src markdown :tangle hosts/theologica/README.md
# Theologica

My daily driver machine, a Lenovo T14s gen 3 laptop.

## Specifications
- Model: Lenovo T14s Gen 3
- Purpose: Daily development and writing work
- Desktop: Hyprland
#+end_src
*** configuration.nix
This declares all imported modules and specific tweaks to the Theologica host:
#+begin_src nix :tangle hosts/theologica/configuration.nix
{ config, pkgs, inputs, ... }:
{
  imports = [
    ./hardware-configuration.nix
    ../../modules/desktop      # This imports the desktop/default.nix
    ../../modules/cli-tui
    ../../modules/development
    ../../modules/media
    ../../modules/home-manager
    ../../modules/security
    # ... other imports
  ];

  # Host-specific configuration
  networking.hostName = "theologica";
  # ... rest of your host config
}
#+end_src

** King
*** README.md
#+begin_src markdown :tangle hosts/king/README.md
# King

My testing machine, a Lenovo T430 laptop.

## Specifications
- Model: Lenovo T430
- Purpose: Testing configurations before deploying to main machine
- Desktop: Hyprland (testing)
#+end_src
** Empirica
*** README.md
#+begin_src markdown :tangle hosts/empirica/README.md
# Empirica

Mini PC running all self-hosted services

## Specifications
- Model: Lenovo M910Q
- Purpose: Hosting all my home server stack
- Headless NixOS Server
#+end_src
*** configuration.nix
Empirica runs all my [[https://joshblais.com/posts/selfhosting/][selfhosted services to get me free from subscriptions]]

#+begin_src nix :tangle hosts/empirica/configuration.nix
{ config, pkgs, inputs, ... }:
{
  imports = [
    ./hardware-configuration.nix
    ../../modules/cli-tui
    ../../modules/home-manager
    ../../modules/security
    ../../modules/services
    # ... other imports
  ];

  # Host-specific configuration
  networking.hostName = "empirica";
  # ... rest of your host config
}
#+end_src
** Alexandria
*** README.md
#+begin_src markdown :tangle hosts/alexandria/README.md
# Alexandria

Hetzner server database host

## Specifications
#+end_src
** Empire
*** README.md
#+begin_src markdown :tangle hosts/empire/README.md
# Empire

Hetzner server running all containers currently -

TODO: migrate all services to nixOS.
## Specifications
#+end_src
** Citadel
* Modules
** Home-manager
I use [[https://github.com/nix-community/home-manager][home-manager]] to manage all dotfiles that require customization.
*** default.nix
#+begin_src nix :tangle modules/home-manager/default.nix
{ config, pkgs, inputs, ... }:

{
  imports = [
    ./git.nix
  ];

  home.username = "joshua";
  home.homeDirectory = "/home/joshua";
  home.stateVersion = "25.05";

  # Let home-manager manage itself
  programs.home-manager.enable = true;

  home.file.".config/doom".source = config.lib.file.mkOutOfStoreSymlink
    "${config.home.homeDirectory}/nixos-config/dotfiles/doom";

  home.file.".config/+STORE".source = config.lib.file.mkOutOfStoreSymlink
    "${config.home.homeDirectory}/nixos-config/dotfiles/+STORE";

  home.file.".tmux.conf".source = config.lib.file.mkOutOfStoreSymlink
    "${config.home.homeDirectory}/nixos-config/dotfiles/tmux.conf";

  home.file.".config/tmux".source = config.lib.file.mkOutOfStoreSymlink
    "${config.home.homeDirectory}/nixos-config/dotfiles/tmux";

  home.file.".config/hypr".source = config.lib.file.mkOutOfStoreSymlink
    "${config.home.homeDirectory}/nixos-config/dotfiles/hypr";

  home.file.".config/waybar".source = config.lib.file.mkOutOfStoreSymlink
    "${config.home.homeDirectory}/nixos-config/dotfiles/waybar";

  home.file.".config/swaync".source = config.lib.file.mkOutOfStoreSymlink
    "${config.home.homeDirectory}/nixos-config/dotfiles/swaync";

  home.file.".config/wofi".source = config.lib.file.mkOutOfStoreSymlink
      "${config.home.homeDirectory}/nixos-config/dotfiles/wofi";
}
#+end_src

*** nvim.nix
*** git.nix
#+begin_src nix :tangle modules/cli-tui/git.nix
{ config, pkgs, ... }:

{
  programs.git = {
    enable = true;
    config = {
      init.defaultBranch = "main";
      user = {
        name = "Joshua Blais";
        email = "josh@joshblais.com";
      };
      core = {
        editor = "nvim";
        autocrlf = "input";
      };
      pull.rebase = true;
      push.autoSetupRemote = true;
    };
  };

  # Install git in system packages too
  environment.systemPackages = with pkgs; [
    git
  ];
}
#+end_src
*** zsh.nix
** Development
*** doom.nix
#+begin_src nix :tangle modules/development/doom.nix
{ config, pkgs, ... }:

{
  # Install Emacs
  home.packages = with pkgs; [
    emacs
    # Doom Emacs dependencies
    git
    ripgrep
    fd
    imagemagick
    texliveFull  # For LaTeX support
    sqlite       # For org-roam
  ];
#+end_src
** CLI/TUI
*** default.nix
#+begin_src nix :tangle modules/cli-tui/default.nix
{ config, pkgs, ... }:

{
  imports = [
    ./git.nix
    ./nvim.nix
    ./zsh.nix
    ./tmux.nix
  ];

  # Tools that don't need configuration - just install them
  environment.systemPackages = with pkgs; [
    # File management
    eza              # Better ls
    yazi             # Terminal file manager
    bat              # Better cat
    fd               # Better find
    ripgrep-all      # Better grep
    fzf              # Fuzzy finder

    # Git tools
    lazygit          # Git TUI

    # System tools
    btop             # Better top
    trash-cli        # Safe rm
    tldr             # Simplified man pages
    fastfetch        # System info

    # Development containers
    podman           # Container runtime
    podman-compose   # Docker-compose for podman
  ];

  # Enable podman
  virtualisation.podman = {
    enable = true;
    dockerCompat = true;  # Create docker alias
    defaultNetwork.settings.dns_enabled = true;
  };
}
#+end_src
*** tmux.nix
#+begin_src nix :tangle modules/cli-tui/tmux.nix
{ config, pkgs, ... }:

{
  # System-level tmux installation
  environment.systemPackages = with pkgs; [
    tmux
  ];

  # Home-manager will handle the config via symlink
  programs.tmux.enable = true;
}
#+end_src
*** podman.nix
#+begin_src nix :tangle modules/cli-tui/podman.nix

#+end_src

** Desktop
*** default.nix
This declares all desktop modules for importing to desktop/laptops
#+begin_src nix :tangle modules/desktop/default.nix
{ config, pkgs, ... }:
{
  imports = [
    ./hyprland.nix
    ./kmonad.nix
    ./kitty.nix
    ./wofi.nix
    # Add any other desktop modules here
  ];
}
#+end_src
*** hyprland.nix (system module)
#+begin_src nix :tangle modules/desktop/hyprland.nix
{ config, pkgs, ... }:

{
  # Enable Hyprland at system level
  programs.hyprland = {
    enable = true;
    xwayland.enable = true;
  };

  # Install Hyprland ecosystem packages
  environment.systemPackages = with pkgs; [
    waybar
    wofi
    kitty
    swww
    grim
    slurp
    wl-clipboard
    hyprlock
    hypridle
    hyprpicker
    hyprutils
    hyprsunset
    wlsunset
    hyprwayland-scanner
    swaynotificationcenter
    polkit_gnome # for authentication flows
  ];
}
#+end_src

*** rofi.nix
Wofi on wayland
#+begin_src nix :tangle modules/desktop/wofi.nix
{ config, pkgs, ... }:
{
  environment.systemPackages = with pkgs; [
    wofi
  ];
}
#+end_src
*** kitty.nix
#+begin_src nix :tangle modules/desktop/kitty.nix
{ config, pkgs, ... }:

{
  environment.systemPackages = with pkgs; [
    kitty
  ];
}
#+end_src
*** kmonad.nix
#+begin_src nix :tangle modules/desktop/kmonad.nix
{ config, pkgs, ... }:
{
  environment.systemPackages = with pkgs; [
    kmonad
  ];

  # Setup Kmonad
  boot.kernelModules = [ "uinput" ];

  services.udev.extraRules = ''
    # KMonad user access to /dev/uinput
    KERNEL=="uinput", MODE="0660", GROUP="input", TAG+="uaccess"
  '';

  # Add your user to the input group
  users.users.joshua.extraGroups = [ "input" ];
}
#+end_src
** Server
** Services
*** default.nix
#+begin_src nix :tangle modules/services/default.nix
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.homelab;
in
{
  options.services.homelab = {
    enable = mkEnableOption "Enable all homelab services";

    mediaDir = mkOption {
      type = types.str;
      default = "/home/joshua/Media";
      description = "Base directory for media files";
    };

    user = mkOption {
      type = types.str;
      default = "joshua";
      description = "Main user for services";
    };

    timezone = mkOption {
      type = types.str;
      default = "America/Edmonton";
      description = "Timezone for services";
    };
  };

  config = mkIf cfg.enable {
    # Jellyfin - Native media server
    services.jellyfin = {
      enable = true;
      openFirewall = true;
      # Jellyfin will auto-detect media in common locations
    };

    # Syncthing - File synchronization
    services.syncthing = {
      enable = true;
      user = cfg.user;
      dataDir = "/home/${cfg.user}/syncthing";
      configDir = "/home/${cfg.user}/.config/syncthing";
      openDefaultPorts = true;
    };

    # The *arr stack for media management
    services.radarr = {
      enable = true;
      openFirewall = true;
    };

    services.lidarr = {
      enable = true;
      openFirewall = true;
    };

    services.prowlarr = {
      enable = true;
      openFirewall = true;
    };

    services.sonarr = {
      enable = true;
      openFirewall = true;
    };

    # Calibre-web for ebook management
    services.calibre-web = {
      enable = true;
      listen.port = 8083;
      openFirewall = true;
      options = {
        calibreLibrary = "${cfg.mediaDir}/books";
        enableBookUploading = true;
      };
    };

    # Nextcloud for cloud storage and collaboration
    services.nextcloud = {
      enable = true;
      hostName = "localhost"; # Change this to your domain
      database.createLocally = true;
      configureRedis = true;
      maxUploadSize = "16G";
      https = false; # Set to true when you have proper domain/certs
      config = {
        adminuser = "admin";
        adminpassFile = "/etc/nixos/nextcloud-admin-pass";
      };
      settings = {
        default_phone_region = "CA";
        maintenance_window_start = 2;
      };
    };

    # Create the admin password file (you'll need to create this)
    environment.etc."nextcloud-admin-pass" = {
      text = "change-this-password";
      mode = "0600";
      user = "nextcloud";
      group = "nextcloud";
    };

    # Plex (alternative to Jellyfin - enable one or the other)
    # services.plex = {
    #   enable = true;
    #   openFirewall = true;
    #   dataDir = "/var/lib/plex";
    # };

    # Create media directories with proper permissions
    systemd.tmpfiles.rules = [
      "d '${cfg.mediaDir}' 0755 ${cfg.user} users - -"
      "d '${cfg.mediaDir}/movies' 0755 ${cfg.user} users - -"
      "d '${cfg.mediaDir}/tvshows' 0755 ${cfg.user} users - -"
      "d '${cfg.mediaDir}/music' 0755 ${cfg.user} users - -"
      "d '${cfg.mediaDir}/books' 0755 ${cfg.user} users - -"
      "d '${cfg.mediaDir}/audiobooks' 0755 ${cfg.user} users - -"
      "d '${cfg.mediaDir}/photos' 0755 ${cfg.user} users - -"
    ];

    # Services that might need container approach (for now)
    virtualisation.podman = {
      enable = true;
      dockerCompat = true;
      defaultNetwork.settings.dns_enabled = true;
    };

    # Container services for things without native NixOS support
    systemd.services = {
      # Audiobookshelf
      audiobookshelf = {
        description = "Audiobookshelf";
        after = [ "network.target" ];
        wantedBy = [ "multi-user.target" ];
        serviceConfig = {
          Type = "exec";
          User = cfg.user;
          Restart = "unless-stopped";
          ExecStart = "${pkgs.podman}/bin/podman run --rm --name audiobookshelf " +
            "-p 13378:80 " +
            "-e TZ=${cfg.timezone} " +
            "-v /home/${cfg.user}/containers/audiobookshelf/config:/config " +
            "-v /home/${cfg.user}/containers/audiobookshelf/metadata:/metadata " +
            "-v ${cfg.mediaDir}/audiobooks:/audiobooks " +
            "ghcr.io/advplyr/audiobookshelf:latest";
          ExecStop = "${pkgs.podman}/bin/podman stop audiobookshelf";
        };
      };

      # Homepage dashboard
      homepage = {
        description = "Homepage Dashboard";
        after = [ "network.target" ];
        wantedBy = [ "multi-user.target" ];
        serviceConfig = {
          Type = "exec";
          User = cfg.user;
          Restart = "unless-stopped";
          ExecStart = "${pkgs.podman}/bin/podman run --rm --name homepage " +
            "-p 3000:3000 " +
            "-e PUID=1000 -e PGID=1000 " +
            "-v /home/${cfg.user}/containers/homepage/config:/app/config " +
            "ghcr.io/gethomepage/homepage:latest";
          ExecStop = "${pkgs.podman}/bin/podman stop homepage";
        };
      };

      # Pi-hole
      pihole = {
        description = "Pi-hole DNS";
        after = [ "network.target" ];
        wantedBy = [ "multi-user.target" ];
        serviceConfig = {
          Type = "exec";
          User = "root"; # Pi-hole needs root for DNS
          Restart = "unless-stopped";
          ExecStart = "${pkgs.podman}/bin/podman run --rm --name pihole " +
            "-p 53:53/tcp -p 53:53/udp -p 8080:80 " +
            "-e TZ=${cfg.timezone} " +
            "-e WEBPASSWORD=changeme " +
            "-v /home/${cfg.user}/containers/pihole/etc-pihole:/etc/pihole " +
            "-v /home/${cfg.user}/containers/pihole/etc-dnsmasq.d:/etc/dnsmasq.d " +
            "docker.io/pihole/pihole:latest";
          ExecStop = "${pkgs.podman}/bin/podman stop pihole";
        };
      };
    };

    # Firewall ports for container services
    networking.firewall = {
      allowedTCPPorts = [ 3000 8080 13378 ];
      allowedUDPPorts = [ 53 ];
    };

    # Create container directories
    systemd.tmpfiles.rules = mkAfter [
      "d '/home/${cfg.user}/containers' 0755 ${cfg.user} users - -"
      "d '/home/${cfg.user}/containers/audiobookshelf/config' 0755 ${cfg.user} users - -"
      "d '/home/${cfg.user}/containers/audiobookshelf/metadata' 0755 ${cfg.user} users - -"
      "d '/home/${cfg.user}/containers/homepage/config' 0755 ${cfg.user} users - -"
      "d '/home/${cfg.user}/containers/pihole/etc-pihole' 0755 ${cfg.user} users - -"
      "d '/home/${cfg.user}/containers/pihole/etc-dnsmasq.d' 0755 ${cfg.user} users - -"
    ];
  };
}
#+end_src

** Shared
** Security
*** fail2ban.nix
*** keychain.nix
#+begin_src nix :tangle modules/security/keychain.nix
# TODO

environment.systemPackages = [
  pkgs.keychain
];
#+end_src
** Media
*** music.nix
#+begin_src nix :tangle modules/media/music.nix

#+end_src
*** video.nix
#+begin_src nix :tangle modules/media/video.nix

#+end_src
*** pdf.nix
#+begin_src nix :tangle modules/media/pdf.nix

#+end_src
* Overlays
* Secrets
We manage secrets with [[https://github.com/ryantm/agenix][agenix]].

The workflow for adding a secret is as follows:
1. Add secret to secrets.nix - specify which keys can decrypt it
2. Create the secret: agenix -e new-secret.age
3. Rekey existing secrets if you added new machines: agenix -r
4. Deploy: Your NixOS systems will automatically decrypt the secrets they have keys for

You can retrieve Machine SSH keys by running ~cat /etc/ssh/ssh_host_ed25519_key.pub~ in any Linux machine with ssh enabled.
** secrets.nix
#+begin_src nix :tangle secrets/secrets.nix
let
  # Your personal SSH public key (from ~/.ssh/joshuakey.pub)
  joshua = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICCWNto66rFbOvb1VDEDuZYdwHQPfKM7+EjpnHvs3eRr joshua@joshuablais.com";

  # Machine SSH host keys
  # king = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBb root@king";
  # theologica = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCc root@theologica";
  # alexandria = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDd root@alexandria";
  # empire = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEe root@empire";


  # Groups for convenience
  users = [ joshua ];
  # desktops = [ king theologica ];
  # servers = [ alexandria empire ];
  # allSystems = desktops ++ servers;
in
{
  # Database secrets (only for servers)
  "postgres-password.age".publicKeys = users;
}
#+end_src

* flake.nix
#+begin_src nix :tangle flake.nix
{
  description = "Joshua Blais' NixOS Configuration";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    nixpkgs-stable.url = "github:NixOS/nixpkgs/nixos-25.05";

    home-manager = {
      url = "github:nix-community/home-manager";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    deploy-rs = {
      url = "github:serokell/deploy-rs";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    agenix = {
      url = "github:ryantm/agenix";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = { self, nixpkgs, home-manager, deploy-rs, agenix, ... }@inputs: {
    nixosConfigurations = {
      # Laptop hosts
      theologica = nixpkgs.lib.nixosSystem {
        system = "x86_64-linux";
        specialArgs = { inherit inputs; };
        modules = [
          ./hosts/theologica/configuration.nix
          agenix.nixosModules.default
          ./modules/shared
          ./modules/desktop
          ./modules/cli-tui
          ./modules/development
          ./modules/media

          # Add home-manager
          home-manager.nixosModules.home-manager
          {
            home-manager.useGlobalPkgs = true;
            home-manager.useUserPackages = true;
            home-manager.users.joshua = import ./modules/home-manager;
            home-manager.extraSpecialArgs = { inherit inputs; };
          }
        ];
      };

      king = nixpkgs.lib.nixosSystem {
        system = "x86_64-linux";
        specialArgs = { inherit inputs; };
        modules = [
          ./hosts/king/configuration.nix
          agenix.nixosModules.default
          ./modules/shared
          ./modules/desktop
          ./modules/cli-tui
          ./modules/development

          # Add home-manager
          home-manager.nixosModules.home-manager
          {
            home-manager.useGlobalPkgs = true;
            home-manager.useUserPackages = true;
            home-manager.users.joshua = import ./modules/home-manager;
            home-manager.extraSpecialArgs = { inherit inputs; };
          }
        ];
      };

      # Server hosts (no home-manager needed)
      alexandria = nixpkgs.lib.nixosSystem {
        system = "x86_64-linux";
        specialArgs = { inherit inputs; };
        modules = [
          ./hosts/alexandria/configuration.nix
          agenix.nixosModules.default
          ./modules/shared
          ./modules/server
          ./modules/services
          ./modules/security
        ];
      };

      empire = nixpkgs.lib.nixosSystem {
        system = "x86_64-linux";
        specialArgs = { inherit inputs; };
        modules = [
          ./hosts/empire/configuration.nix
          agenix.nixosModules.default
          ./modules/shared
          ./modules/server
          ./modules/security
        ];
      };
    };

    # Deploy-rs configuration for remote deployment
    deploy.nodes = {
      alexandria = {
        hostname = "alexandria.your-domain.com";
        profiles.system = {
          user = "root";
          path = deploy-rs.lib.x86_64-linux.activate.nixos self.nixosConfigurations.alexandria;
        };
      };
    };
  };
}
#+end_src
